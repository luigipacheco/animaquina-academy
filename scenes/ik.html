---
layout: fullscreen
title: Animaquina Academy - IK Controls
---

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { TransformControls } from 'three/addons/controls/TransformControls.js';

  let scene, camera, renderer, controls;
  let model, armature, bones = [];
  let boneLines = [];
  let target, raycaster, mouse, plane;
  let isDragging = false;
  let dragPlane = new THREE.Plane();
  let dragPoint = new THREE.Vector3();
  let maxIterations = 10;
  let tolerance = 0.01;
  let constraintUI;
  let transformControl;

  // Define joint constraints based on FK file
  const jointConstraints = {
    'j1': { axis: 'Y', min: THREE.MathUtils.degToRad(-170), max: THREE.MathUtils.degToRad(170), rotationOrder: 'XYZ' },  // A1 ±170°
    'j2': { axis: 'Z', min: THREE.MathUtils.degToRad(-190), max: THREE.MathUtils.degToRad(45), rotationOrder: 'XYZ' },   // A2 -190° / 45°
    'j3': { axis: 'Y', min: THREE.MathUtils.degToRad(-120), max: THREE.MathUtils.degToRad(156), rotationOrder: 'XYZ' },  // A3 -120° / 156°
    'j4': { axis: 'Y', min: THREE.MathUtils.degToRad(-185), max: THREE.MathUtils.degToRad(185), rotationOrder: 'XYZ' },  // A4 ±185°
    'j5': { axis: 'X', min: THREE.MathUtils.degToRad(-120), max: THREE.MathUtils.degToRad(120), rotationOrder: 'XYZ' },  // A5 ±120°
    'j6': { axis: 'Y', min: THREE.MathUtils.degToRad(-350), max: THREE.MathUtils.degToRad(350), rotationOrder: 'XYZ' }   // A6 ±350°
  };

  function createBoneLine(bone1, bone2) {
    const points = [
      bone1.getWorldPosition(new THREE.Vector3()),
      bone2.getWorldPosition(new THREE.Vector3())
    ];
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
    const line = new THREE.Line(geometry, material);
    scene.add(line);
    boneLines.push({ line, bone1, bone2 });
    return line;
  }

  function updateBoneLines() {
    boneLines.forEach(({ line, bone1, bone2 }) => {
      const positions = line.geometry.attributes.position;
      const pos1 = bone1.getWorldPosition(new THREE.Vector3());
      const pos2 = bone2.getWorldPosition(new THREE.Vector3());
      
      positions.setXYZ(0, pos1.x, pos1.y, pos1.z);
      positions.setXYZ(1, pos2.x, pos2.y, pos2.z);
      positions.needsUpdate = true;
    });
  }

  function createTarget() {
    // Create target sphere
    const geometry = new THREE.SphereGeometry(0.15, 32, 32);
    const material = new THREE.MeshBasicMaterial({ 
      color: 0xffff00,
      transparent: true,
      opacity: 0.6
    });
    target = new THREE.Mesh(geometry, material);
    
    // Add a direction indicator to the target
    const arrowGeometry = new THREE.ConeGeometry(0.05, 0.2, 8);
    const arrowMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
    arrow.position.y = 0.15; // Position at top of sphere
    arrow.rotation.x = -Math.PI / 2; // Point upward
    target.add(arrow);
    
    // Add an up indicator
    const upArrowGeometry = new THREE.ConeGeometry(0.05, 0.2, 8);
    const upArrowMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const upArrow = new THREE.Mesh(upArrowGeometry, upArrowMaterial);
    upArrow.position.z = 0.15; // Position at front of sphere
    upArrow.rotation.x = Math.PI; // Point forward
    target.add(upArrow);
    
    // Position will be set after model loads
    scene.add(target);

    // Add transform controls
    transformControl = new TransformControls(camera, renderer.domElement);
    transformControl.attach(target);
    transformControl.addEventListener('dragging-changed', function(event) {
      controls.enabled = !event.value;
    });
    transformControl.addEventListener('change', function() {
      // Log target rotation for debugging
      const euler = new THREE.Euler().setFromQuaternion(target.quaternion);
      console.log('Target rotation:', {
        quaternion: target.quaternion,
        euler: {
          x: THREE.MathUtils.radToDeg(euler.x),
          y: THREE.MathUtils.radToDeg(euler.y),
          z: THREE.MathUtils.radToDeg(euler.z)
        }
      });
    });
    scene.add(transformControl);

    // Create invisible plane for dragging
    plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
  }

  function constrainRotation(bone, targetRotation) {
    const constraint = jointConstraints[bone.name.toLowerCase()];
    if (!constraint) return targetRotation;

    // Convert to Euler angles with the correct rotation order
    const euler = new THREE.Euler();
    euler.setFromQuaternion(targetRotation, constraint.rotationOrder);

    // Create a new Euler with only the allowed axis rotation
    const constrainedEuler = new THREE.Euler(0, 0, 0, constraint.rotationOrder);
    
    // Get the rotation value from the appropriate axis
    const rotationValue = euler[constraint.axis.toLowerCase()];
    
    // Apply the rotation only to the selected axis
    constrainedEuler[constraint.axis.toLowerCase()] = Math.max(
      constraint.min,
      Math.min(constraint.max, rotationValue)
    );

    // Convert back to quaternion
    const result = new THREE.Quaternion().setFromEuler(constrainedEuler);
    
    // Debug log for j3
    if (bone.name.toLowerCase() === 'j3') {
      console.log('j3 rotation:', {
        originalEuler: euler,
        constrainedEuler: constrainedEuler,
        resultQuaternion: result,
        axis: constraint.axis,
        rotationValue: rotationValue
      });
    }

    return result;
  }

  function solveIK() {
    const targetPos = target.position.clone();
    const targetRot = target.quaternion.clone();
    const endEffector = bones[bones.length - 1];
    const endEffectorPos = endEffector.getWorldPosition(new THREE.Vector3());
    
    // If target is too far, just point towards it
    if (endEffectorPos.distanceTo(targetPos) > 5) {
      const direction = targetPos.clone().sub(endEffectorPos).normalize();
      const rotation = new THREE.Quaternion().setFromUnitVectors(
        new THREE.Vector3(0, 1, 0),
        direction
      );
      endEffector.quaternion.copy(constrainRotation(endEffector, rotation));
      return;
    }

    // Simplified CCD IK with stronger damping
    const damping = 0.3; // Increased damping for more stability
    for (let iteration = 0; iteration < maxIterations; iteration++) {
      let maxError = 0;
      
      // Work from end to base
      for (let i = bones.length - 1; i >= 0; i--) {
        const bone = bones[i];
        const bonePos = bone.getWorldPosition(new THREE.Vector3());
        const endPos = endEffector.getWorldPosition(new THREE.Vector3());
        
        // Calculate vectors
        const toEnd = endPos.clone().sub(bonePos).normalize();
        const toTarget = targetPos.clone().sub(bonePos).normalize();
        
        // Calculate rotation to align with target
        let rotation = new THREE.Quaternion().setFromUnitVectors(toEnd, toTarget);
        
        // For the end effector, also consider target orientation
        if (i === bones.length - 1) {
          // Get the current forward direction of the end effector
          const currentForward = new THREE.Vector3(0, 1, 0).applyQuaternion(endEffector.quaternion);
          const currentUp = new THREE.Vector3(0, 0, 1).applyQuaternion(endEffector.quaternion);
          
          // Get the target's forward and up directions
          const targetForward = new THREE.Vector3(0, 1, 0).applyQuaternion(targetRot);
          const targetUp = new THREE.Vector3(0, 0, 1).applyQuaternion(targetRot);
          
          // Calculate rotation to align forward directions
          const forwardRotation = new THREE.Quaternion().setFromUnitVectors(currentForward, targetForward);
          
          // Calculate rotation to align up directions
          const upRotation = new THREE.Quaternion().setFromUnitVectors(
            currentUp.applyQuaternion(forwardRotation),
            targetUp
          );
          
          // Combine rotations
          rotation = forwardRotation.multiply(upRotation);
          
          // Debug logging
          console.log('End effector rotation:', {
            currentForward,
            targetForward,
            currentUp,
            targetUp,
            forwardRotation,
            upRotation,
            finalRotation: rotation
          });
        }
        
        // Apply stronger damping to rotation
        rotation.slerp(new THREE.Quaternion(), 1 - damping);
        
        // Apply constrained rotation
        const constrainedRotation = constrainRotation(bone, rotation);
        
        // Apply rotation with additional damping
        const currentRotation = bone.quaternion.clone();
        bone.quaternion.slerp(currentRotation.multiply(constrainedRotation), damping);
        
        // Update error
        const newEndPos = endEffector.getWorldPosition(new THREE.Vector3());
        const error = newEndPos.distanceTo(targetPos);
        maxError = Math.max(maxError, error);
        
        // Early exit if we're close enough
        if (error < tolerance) {
          return;
        }
      }
      
      // If error isn't decreasing significantly, stop iterating
      if (maxError < tolerance * 2) {
        break;
      }
    }
  }

  function createConstraintUI() {
    const container = document.createElement('div');
    container.style.position = 'absolute';
    container.style.top = '10px';
    container.style.right = '10px';
    container.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
    container.style.padding = '10px';
    container.style.color = 'white';
    container.style.fontFamily = 'monospace';
    container.style.maxHeight = '80vh';
    container.style.overflowY = 'auto';
    container.style.zIndex = '1000';

    const title = document.createElement('h3');
    title.textContent = 'Joint Constraints';
    title.style.margin = '0 0 10px 0';
    container.appendChild(title);

    // Create controls for each bone
    bones.forEach(bone => {
      const boneName = bone.name.toLowerCase();
      const constraint = jointConstraints[boneName];
      
      const boneContainer = document.createElement('div');
      boneContainer.style.marginBottom = '15px';
      boneContainer.style.padding = '10px';
      boneContainer.style.border = '1px solid #444';
      boneContainer.style.borderRadius = '5px';

      const boneTitle = document.createElement('h4');
      boneTitle.textContent = boneName;
      boneTitle.style.margin = '0 0 10px 0';
      boneContainer.appendChild(boneTitle);

      // Rotation axis selector
      const axisContainer = document.createElement('div');
      axisContainer.style.marginBottom = '5px';
      
      const axisLabel = document.createElement('label');
      axisLabel.textContent = 'Rotation Axis: ';
      axisContainer.appendChild(axisLabel);

      const axisSelect = document.createElement('select');
      ['X', 'Y', 'Z'].forEach(axis => {
        const option = document.createElement('option');
        option.value = axis;
        option.textContent = axis;
        if (axis === constraint.axis) option.selected = true;
        axisSelect.appendChild(option);
      });
      
      axisSelect.addEventListener('change', (e) => {
        constraint.axis = e.target.value;
        // Reset the bone's rotation when changing axis
        bone.quaternion.setFromEuler(new THREE.Euler(0, 0, 0));
        console.log(`Changed ${boneName} axis to ${e.target.value}`);
      });
      
      axisContainer.appendChild(axisSelect);
      boneContainer.appendChild(axisContainer);

      // Min rotation input
      const minContainer = document.createElement('div');
      minContainer.style.marginBottom = '5px';
      
      const minLabel = document.createElement('label');
      minLabel.textContent = 'Min Rotation: ';
      minContainer.appendChild(minLabel);

      const minInput = document.createElement('input');
      minInput.type = 'number';
      minInput.value = constraint.min;
      minInput.step = '0.1';
      minInput.style.width = '60px';
      minInput.addEventListener('change', (e) => {
        constraint.min = parseFloat(e.target.value);
        console.log(`Changed ${boneName} min to ${e.target.value}`);
      });
      
      minContainer.appendChild(minInput);
      boneContainer.appendChild(minContainer);

      // Max rotation input
      const maxContainer = document.createElement('div');
      maxContainer.style.marginBottom = '5px';
      
      const maxLabel = document.createElement('label');
      maxLabel.textContent = 'Max Rotation: ';
      maxContainer.appendChild(maxLabel);

      const maxInput = document.createElement('input');
      maxInput.type = 'number';
      maxInput.value = constraint.max;
      maxInput.step = '0.1';
      maxInput.style.width = '60px';
      maxInput.addEventListener('change', (e) => {
        constraint.max = parseFloat(e.target.value);
        console.log(`Changed ${boneName} max to ${e.target.value}`);
      });
      
      maxContainer.appendChild(maxInput);
      boneContainer.appendChild(maxContainer);

      // Current rotation display
      const currentContainer = document.createElement('div');
      currentContainer.style.marginBottom = '5px';
      
      const currentLabel = document.createElement('label');
      currentLabel.textContent = 'Current Rotation: ';
      currentContainer.appendChild(currentLabel);

      const currentValue = document.createElement('span');
      currentValue.id = `${boneName}-current`;
      currentValue.textContent = '0.00';
      currentContainer.appendChild(currentValue);
      
      boneContainer.appendChild(currentContainer);

      container.appendChild(boneContainer);
    });

    document.body.appendChild(container);
    constraintUI = container;
  }

  function updateConstraintUI() {
    bones.forEach(bone => {
      const boneName = bone.name.toLowerCase();
      const currentElement = document.getElementById(`${boneName}-current`);
      if (currentElement) {
        const euler = new THREE.Euler();
        euler.setFromQuaternion(bone.quaternion);
        const constraint = jointConstraints[boneName];
        const currentRotation = euler[constraint.axis.toLowerCase()];
        currentElement.textContent = currentRotation.toFixed(2);
      }
    });
  }

  function setupArmature(gltf) {
    model = gltf.scene;
    scene.add(model);

    // Center and scale the model
    const box = new THREE.Box3().setFromObject(model);
    const center = box.getCenter(new THREE.Vector3());
    model.position.sub(center);
    
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    const scale = 2 / maxDim;
    model.scale.multiplyScalar(scale);

    // Log the entire scene structure
    console.log('Scene structure:');
    model.traverse((object) => {
      console.log('Object:', object.name, 'Type:', object.type);
      if (object.isBone) {
        console.log('  Bone position:', object.position);
        console.log('  Bone rotation:', object.quaternion);
        console.log('  Bone matrix:', object.matrix);
        console.log('  Parent:', object.parent ? object.parent.name : 'none');
        // Log local axes
        const axes = new THREE.Object3D();
        axes.position.copy(object.position);
        axes.quaternion.copy(object.quaternion);
        console.log('  Local X axis:', new THREE.Vector3(1, 0, 0).applyQuaternion(axes.quaternion));
        console.log('  Local Y axis:', new THREE.Vector3(0, 1, 0).applyQuaternion(axes.quaternion));
        console.log('  Local Z axis:', new THREE.Vector3(0, 0, 1).applyQuaternion(axes.quaternion));
      }
    });

    // Find the armature and bones
    model.traverse((object) => {
      if (object.isBone) {
        if (object.name.toLowerCase() in jointConstraints) {
        bones.push(object);
          console.log('Found bone:', object.name, 'Position:', object.position);
        }
      }
    });

    // Sort bones by name to ensure correct order
    bones.sort((a, b) => {
      const order = ['j1', 'j2', 'j3', 'j4', 'j5', 'j6'];
      return order.indexOf(a.name.toLowerCase()) - order.indexOf(b.name.toLowerCase());
    });

    // Store original bone positions and rotations
    bones.forEach(bone => {
      bone.userData.originalPosition = bone.position.clone();
      bone.userData.originalRotation = bone.quaternion.clone();
      console.log('Stored original data for', bone.name, ':', {
        position: bone.userData.originalPosition,
        rotation: bone.userData.originalRotation
      });
    });

    // Create lines between bones
    for (let i = 0; i < bones.length - 1; i++) {
      createBoneLine(bones[i], bones[i + 1]);
    }

    // Position target at the end effector (last bone)
    if (bones.length > 0) {
      const endEffector = bones[bones.length - 1];
      const endPos = endEffector.getWorldPosition(new THREE.Vector3());
      target.position.copy(endPos);
      console.log('Target positioned at end effector:', endPos);
    }

    console.log('Armature created with bones:', bones.map(b => b.name));

    // Create the constraint UI after bones are loaded
    createConstraintUI();
  }

  function onMouseDown(event) {
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(target);
    
    if (intersects.length > 0) {
      isDragging = true;
      controls.enabled = false;
      
      // Update drag plane
      dragPlane.setFromNormalAndCoplanarPoint(
        camera.getWorldDirection(dragPlane.normal),
        target.position
      );
    }
  }

  function onMouseMove(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    if (isDragging) {
      raycaster.setFromCamera(mouse, camera);
      raycaster.ray.intersectPlane(dragPlane, dragPoint);
      target.position.copy(dragPoint);
    }
  }

  function onMouseUp() {
    isDragging = false;
    controls.enabled = true;
  }

  function init() {
    // Create scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    // Create camera
    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);

    // Create renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // Add orbit controls
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 1;
    controls.maxDistance = 20;
    controls.maxPolarAngle = Math.PI / 2;

    // Add lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    // Add axes helper
    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    // Create target
    createTarget();

    // Setup mouse controls
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    
    window.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    window.addEventListener('resize', onWindowResize);

    // Add transform mode controls
    const transformModes = document.createElement('div');
    transformModes.style.position = 'absolute';
    transformModes.style.bottom = '20px';
    transformModes.style.left = '20px';
    transformModes.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
    transformModes.style.padding = '10px';
    transformModes.style.color = 'white';
    transformModes.style.fontFamily = 'monospace';
    transformModes.style.borderRadius = '5px';
    transformModes.style.zIndex = '1000';
    transformModes.innerHTML = `
      <div>Transform Controls:</div>
      <div>G - Move</div>
      <div>R - Rotate</div>
      <div>S - Scale</div>
      <div>Current Mode: <span id="transform-mode">Move</span></div>
    `;
    document.body.appendChild(transformModes);

    // Add keyboard shortcuts for transform modes
    window.addEventListener('keydown', function(event) {
      switch (event.key.toLowerCase()) {
        case 'g': // translate
          transformControl.setMode('translate');
          document.getElementById('transform-mode').textContent = 'Move';
          break;
        case 'r': // rotate
          transformControl.setMode('rotate');
          document.getElementById('transform-mode').textContent = 'Rotate';
          break;
        case 's': // scale
          transformControl.setMode('scale');
          document.getElementById('transform-mode').textContent = 'Scale';
          break;
      }
    });

    // Load the model
    const loader = new GLTFLoader();
    loader.load('/assets/scene/test.glb',
      function(gltf) {
        console.log('Model loaded successfully');
        setupArmature(gltf);
      },
      function(xhr) {
        console.log((xhr.loaded / xhr.total * 100) + '% loaded');
      },
      function(error) {
        console.error('Error loading model:', error);
      }
    );
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function updateHelpers() {
    // Update bone lines
    updateBoneLines();
  }

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    
    // Solve IK
    solveIK();
    
    // Update helpers and lines
    updateHelpers();
    updateBoneLines();
    updateConstraintUI();
    
    renderer.render(scene, camera);
  }

  init();
  animate();
</script>

<style>
  body, html { 
    margin: 0; 
    padding: 0; 
    overflow: hidden; 
    height: 100vh;
    width: 100vw;
  }
  canvas { 
    display: block;
    width: 100%;
    height: 100%;
    position: fixed;
    top: 0;
    left: 0;
  }
</style> 